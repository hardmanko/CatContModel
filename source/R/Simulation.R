


#' Sample Data from Model with Specific Parameter Values
#' 
#' Samples data from the model given the provided parameter values. 
#' This is useful for observing patterns of data generated by the model variants and for sampling from the posterior predictive distribution of the data.
#' 
#' @param study A vector of study angles in degrees.
#' @param manPar A list of manifest parameter values like the return value of [`getSingleIterationParameters`]. `catMu` should be a vector. If there are no categories, `catMu` should be `NULL`.
#' @param modelVariant The model variant, as a string. Should be one of "betweenItem", "withinItem", and "ZL".
#' @param dataType One of `"circular"` or `"linear"`.
#' @param responseRange A length 2 vector giving the theoretical minimum and maximum values of a response. Should be provided if `dataType` is `"linear"`.
#' 
#' @return A data frame containing the `study` angles, the sampled `response` angles, the response `type` (e.g. continuous memory response), and, if the response was categorical in nature, the category it was from (`cat`).
#'
#' @seealso posteriorPredictivePlot
#' 
#' @family simulationFunctions
#'
#' @export
sampleDataFromModel = function(study, manPar, modelVariant, dataType = "circular", responseRange = NULL) {
  
  trials = length(study)
  
  manPar = checkManifestParameterList(manPar, modelVariant)
  
  # Parameter values restrictions for reduced models
  if (modelVariant == "betweenItem") {
    manPar$pBetween = 1
  } else if (modelVariant == "withinItem") {
    manPar$pBetween = 0
  } else if (modelVariant == "ZL") {
    manPar$pBetween = 1
    manPar$pContBetween = 1
    manPar$pCatGuess = 0
    manPar$catMu = NULL
  }
  
  
  
  realzationFunction = NULL
  unifGuessFunction = NULL
  if (dataType == "circular") {
    
    realzationFunction = function(mu, sd) {
      CatContModel::rVonMises(1, mu, sd, degrees=TRUE)
    }
    unifGuessFunction = function() {
      stats::runif(1, 0, 360)
    }
    
  } else if (dataType == "linear") {
    
    realzationFunction = function(mu, sd) {
      msm::rtnorm(1, mu, sd, responseRange[1], responseRange[2])
    }
    unifGuessFunction = function() {
      stats::runif(1, responseRange[1], responseRange[2])
    }
  }
  
  
  catCount = length(manPar$catMu)
  
  
  response = rep(0, trials)
  
  cat = rep(0, trials)
  type = rep("none", trials)
  
  for (i in 1:trials) {
    
    inMemory = (stats::rbinom(1, 1, manPar$pMem) == 1)
    
    if (!inMemory) {
      
      isCatGuess = (stats::rbinom(1, 1, manPar$pCatGuess) == 1)
      
      if (isCatGuess && (catCount > 0)) {
        cat[i] = sample(1:catCount, size=1)
        
        response[i] = realzationFunction(manPar$catMu[cat[i]], manPar$catSD)
        type[i] = "catGuess"
      } else {
        response[i] = unifGuessFunction()
        type[i] = "unifGuess"
      }
      
    } else {
      
      # Pick an error for the continuous representation
      
      contLocation = realzationFunction(study[i], manPar$contSD)
      
      if (dataType == "circular") {
        contLocation = contLocation %% 360
      }
      
      if (catCount == 0) {
        response[i] = contLocation
        type[i] = "continuous"
        
      } else {
        
        # Pick a category for the color
        catWeights = categoryWeightsFunction(study[i], manPar$catMu, manPar$catSelectivity, dataType = dataType)
        catEgory = sample(1:catCount, size=1, prob=catWeights)
        cat[i] = catEgory
        
        
        # Get the categorical response location
        catLocation = realzationFunction(manPar$catMu[catEgory], manPar$catSD)
        if (dataType == "circular") {
          catLocation = catLocation %% 360
        }
        
        isBetween = (stats::rbinom(1, 1, manPar$pBetween) == 1)
        
        if (isBetween) {
          # This is a between response
          isContinuous = (stats::rbinom(1, 1, manPar$pContBetween) == 1)
          
          if (isContinuous) {
            response[i] = contLocation
            type[i] = "continuous"
          } else {
            response[i] = catLocation
            type[i] = "categorical"
          }
        } else {
          # This is a within response
          
          locMix = NA
          if (dataType == "circular") {
            locMix = circMean(c(contLocation, catLocation), c(manPar$pContWithin, 1 - manPar$pContWithin))
            locMix = locMix %% 360
          } else if (dataType == "linear") {
            locMix = manPar$pContWithin * contLocation + (1 - manPar$pContWithin) * catLocation
          }
          
          response[i] = locMix
          
          type[i] = "within"
        }
      }
    } # inMemory
  } # trials
  
  data.frame(study=study, response=response, type=type, cat=cat)
}



#' Define Condition Effects for Data Simulation
#' 
#' Utility function for data simulation used to define condition effects. Note that all condition effects are defined in the latent space.
#' 
#' @param nCond Number of conditions that are being defined.
#' @param condNames Optional. Names of conditions, same length as `nCond`.
#' @param pMem,pContBetween,pContWithin,pBetween,pCatGuess,contSD,catSD,catSelectivity Vector of length `nCond` giving latent condition effects.
#' @param modelVariant Model variant that will be sampled from. Used to filter out unused parameters for the `modelVariant`.
#' 
#' @return A list containing the condition effects, to be passed as the `conditionEffects` argument of [`SIM_sampleDataSet`].
#' 
#' @family simulationFunctions
#' @export
SIM_defineConditionEffects = function(nCond, 
                                  condNames = paste0("C", 1:nCond),
                                  pMem = rep(0, nCond),
                                  pContBetween = rep(0, nCond),
                                  pContWithin = rep(0, nCond),
                                  pBetween = rep(0, nCond),
                                  pCatGuess = rep(0, nCond),
                                  contSD = rep(0, nCond),
                                  catSD = rep(0, nCond),
                                  catSelectivity = rep(0, nCond),
                                  modelVariant = NULL
) 
{

  condEffects = list(
    pMem = pMem,
    pContBetween = pContBetween,
    pContWithin = pContWithin,
    pBetween = pBetween,
    pCatGuess = pCatGuess,
    contSD = contSD,
    catSD = catSD,
    catSelectivity = catSelectivity
  )
  
  # Filter parameter by model varant
  if (!is.null(modelVariant)) {
    pn = getParamNames(modelVariant)
    for (n in names(condEffects)) {
      if (!(n %in% pn)) {
        condEffects[[n]] = NULL
      }
    }
  }
  
  condEffects$condNames = condNames
  
  for (n in names(condEffects)) {
    if (length(condEffects[[n]]) != nCond) {
      stop(paste0("Wrong number of condition effects for ", n))
    }
  }
  
  condEffects
}


#' Sample Participant-Level Parameter Values for Data Simulation
#' 
#' Utility function for data simulation used to sample participants based on population values for participant parameters.
#' 
#' @details Note that `nCat` is the number of categories.
#' 
#' @param nPart Number of participants to sample.
#' @param pMem,pContBetween,pContWithin,pBetween,pCatGuess,contSD,catSD,catSelectivity,nCat A list with `mean` and `sd` elements giving the (manifest) mean and standard deviation of the population distributions for these parameters.
#' @param catMuPopulation A vector of `catMu` values to be sampled from for each participant. The `nCat` list defines the population of the number of categories to sample from `catMuPopulation`.
#' @param probParamRange,sdParamRange,nCatRange The lower and upper bounds for probability parameters, standard deviation parameters, and number of categories.
#' @param modelVariant Model variant that will be sampled from. Used to filter out unused parameters for the `modelVariant`.
#' 
#' @return A list containing the sampled participant parameters, to be passed as the `partParam` argument of [`SIM_sampleDataSet`].
#' 
#' @family simulationFunctions
#' @export
SIM_sampleParticipants = function(nPart, 
                                       pMem =           list(mean = 0.6, sd = 0.06),
                                       pContBetween =   list(mean = 0.5, sd = 0.06),
                                       pContWithin =    list(mean = 0.5, sd = 0.06),
                                       pBetween =       list(mean = 0.5, sd = 0.06),
                                       pCatGuess =      list(mean = 0.5, sd = 0.08),
                                       contSD =         list(mean = 12,  sd = 1.5),
                                       catSD =          list(mean =  8,  sd = 1),
                                       catSelectivity = list(mean = 10,  sd = 1.2),
                                       nCat =           list(mean =  8,  sd = 1.2),
                                       catMuPopulation = NULL,
                                       probParamRange = c(0.01, 0.99), 
                                       sdParamRange = c(1.5, 100), 
                                       nCatRange = c(0, 16),
                                       modelVariant = NULL
) 
{

  partCfg = list(
    pMem = pMem,
    pContBetween = pContBetween,
    pContWithin = pContWithin,
    pBetween = pBetween,
    pCatGuess = pCatGuess,
    contSD = contSD,
    catSD = catSD,
    catSelectivity = catSelectivity,
    nCat = nCat
  )
  
  mvParam = getParamNames(modelVariant)
  mvParam[ mvParam == "catActive" ] = "nCat"
  for (n in names(partCfg)) {
    if (!(n %in% mvParam)) {
      partCfg[[n]] = NULL
    }
  }
  
  if ("catMu" %in% mvParam) {
    if (is.null(catMuPopulation)) {
    	logWarning("No catMu population provided. It will be sampled based on the max of nCatRange.")
      catMuPopulation = SIM_sampleCatMuGrid(nCatRange[2])
    }
    
    if (nCatRange[2] > length(catMuPopulation)) {
    	logWarning("nCatRange[2] reduced to length(catMuPopulation).")
      nCatRange[2] = length(catMuPopulation)
    }
  }
  
  partParam = list()
  for (n in names(partCfg)) {
    
    if (n %in% getParamNames(modelVariant, types="prob")) {
      partParam[[n]] = msm::rtnorm(nPart, partCfg[[n]]$mean, partCfg[[n]]$sd, probParamRange[1], probParamRange[2])
      
    } else if (n %in% getParamNames(modelVariant, types="sd")) {
      partParam[[n]] = msm::rtnorm(nPart, partCfg[[n]]$mean, partCfg[[n]]$sd, sdParamRange[1], sdParamRange[2])
      
    } else if (n == "nCat") {
      partParam$nCat = msm::rtnorm(nPart, partCfg[[n]]$mean, partCfg[[n]]$sd, nCatRange[1], nCatRange[2])
      partParam$nCat = round(partParam$nCat, 0)
      
    }
    
  }
  
  # Sample catMu from population
  if ("catMu" %in% mvParam) {
    
    catMuMat = matrix(NA, nrow=nPart, ncol=max(partParam$nCat))
    for (i in 1:nPart) {
      
      nCat = partParam$nCat[i]
      if (nCat > 0) {
        catMuMat[i, 1:nCat] = sample(catMuPopulation, nCat, replace=FALSE)
      }
    }
    
    partParam$catMu = catMuMat

  }
  
  partParam
}


#' Sample catMu values from a Noisy Grid
#' 
#' Used for simulations.
#' 
#' @param sampleSize Number of `catMu` values to sample.
#' @param gridSize The number of values in the grid that is sampled from.
#' @param noiseScale If 0, no noise is added to the grid. If 1, sampled values are taken from between the edges of a grid bin (i.e. two sampled values could be equal).
#' @param linear If `TRUE`, sampling is done as for linear data.
#' @param catRange Range of possible `catMu` values (for linear data).
#' 
#' @return A vector of `catMu` values.
#' 
#' @family simulationFunctions
#' @export
SIM_sampleCatMuGrid = function(sampleSize, gridSize=sampleSize, noiseScale = 0.5, linear = FALSE, catRange = c(0, 360)) {

  if (sampleSize == 0) {
    return(NULL)
  }
  if (sampleSize > gridSize) {
    sampleSize = gridSize
    logWarning("sampleSize > gridSize")
  }
  if (noiseScale <= 0 || noiseScale >= 1) {
  	stop("noiseScale must be between 0 and 1")
  }
  
  rangeWidth = catRange[2] - catRange[1]
  
  noiseRange = noiseScale * rangeWidth / gridSize / 2
  
  gridLocations = seq(catRange[1], catRange[2] * (gridSize - 1)/gridSize, length.out=gridSize)
  if (linear) {
    # Inset locations based on noise range
    gridLocations = seq(catRange[1] + noiseRange, catRange[2] - noiseRange, length.out=gridSize)
  }
  
  catMu = sample(gridLocations, sampleSize, replace=FALSE)
  
  catMu = catMu + stats::runif(sampleSize, -noiseRange, noiseRange)
  
  # Force into range
  catMu = ((catMu - catRange[1]) %% rangeWidth) + catRange[1]
  
  sort(catMu)
}




#' Sample a Simulated Data Set
#'
#' @param conditionEffects A list formatted like the return value of [`SIM_defineConditionEffects`].
#' @param partParam A list formatted like the return value of [`SIM_sampleParticipants`].
#' @param nTrials Number of trials per participant per condition. Should be a scalar or a vector of length equal to the number of conditions in `conditionEffects`.
#' @param modelVariant The model variant to sample from (passed to [`sampleDataFromModel`]).
#' @param dataType One of "circular" or "linear". If "linear", you should also set `studyRange` and `responseRange`.
#' @param minSD Minimum value for standard deviation parameters.
#' @param studyRange Range of study values (for linear data).
#' @param responseRange Range of response values (for linear data).
#' @param combinedParameterList If `TRUE`, a list of parameters (`paramList`) will also be returned. This list is easy to use with [`sampleDataFromModel`] but is otherwise not very useful.
#' 
#' @return A list containing the `simulatedData` and a data.frame of the parameters used to generate the data (`paramDf`).
#'
#' @family simulationFunctions
#' @export
SIM_sampleDataSet = function(conditionEffects, partParam, nTrials, 
															 modelVariant, 
															 dataType = "circular", 
															 minSD = 1, studyRange = NULL, responseRange = NULL, combinedParameterList=FALSE) 
{

  condNames = conditionEffects$condNames
	nCond = length(conditionEffects$pMem)
	nPart = length(partParam$pMem)
	
	if (length(nTrials) != nCond) {
	  if (length(nTrials) == 1) {
	    nTrials = rep(nTrials, nCond)
	  } else {
	    stop("The length of nTrials does not equal the number of conditions")
	  }
	}
	
	# Convert participant parameter vectors (per parameter) to lists (per participant)
	ppList = list()
	
	if (modelVariant == "ZL") {
		partParam$nCat = rep(0, nPart)
	}
	
	for (pnum in 1:nPart) {
		
		pp = list()
		
		for (pn in names(partParam)) {
			pp[[pn]] = partParam[[pn]][pnum]
		}

		# Select only active categories (the first nCat cats)
		if (partParam$nCat[pnum] > 0) {
			pp$catMu = partParam$catMu[pnum, 1:partParam$nCat[pnum]]
		}
		
		ppList[[pnum]] = pp
		
	}
	
	# Make lists of manifest parameters for each participant in each condition
	combinedParam = list()
	for (cond in 1:nCond) {
		combinedParam[[ condNames[cond] ]] = ppList
	}
	
	#apply condition param
	for (pnum in 1:nPart) {
		
		for (cond in 1:nCond) {
			
			for (pp in getParamNames(modelVariant, types="prob")) {
			  
			  toManifest = getParameterTransformation(NULL, pp)
			  toLatent = getParameterTransformation(NULL, pp, inverse=TRUE)
			  
				lpp = toLatent(ppList[[pnum]][[pp]]) #Transform back to latent space
				ce = conditionEffects[[pp]][cond]
				
				combinedParam[[ condNames[cond] ]][[pnum]][[pp]] = toManifest(lpp + ce)
			}
			
			for (sp in getParamNames(modelVariant, types="sd")) {
				part = ppList[[pnum]][[sp]]
				ce = conditionEffects[[sp]][cond]
				
				toManifest = getParameterTransformation(NULL, sp, minSD=minSD)
				
				combinedParam[[ condNames[cond] ]][[pnum]][[sp]] = toManifest(part + ce)
			}
		}
	}
	
	if (dataType == "circular") {
	  studyRange = responseRange = c(0, 360)
	} else {
	  if (is.null(responseRange)) {
	    stop("Must set responseRange for linear data. (See also studyRange.)")
	  }
	}
	
	if (is.null(studyRange)) {
		studyRange = responseRange
	}
	
	
	# Sample the data
	simulatedData = NULL
	
	for (pn in 1:nPart) {
		for (cond in 1:nCond) {
			trials = nTrials[cond]
			
			manifestPar = combinedParam[[ condNames[cond] ]][[pn]]
			
			studyValues = stats::runif(trials, studyRange[1], studyRange[2])
			
			samp = sampleDataFromModel(studyValues, manifestPar, 
			                           modelVariant=modelVariant, 
																 dataType=dataType, 
																 responseRange=responseRange)
			
			data = data.frame(pnum=pn, cond=condNames[cond], study=samp$study, response=samp$response, type=samp$type)
			
			
			simulatedData = rbind(simulatedData, data)
		}
	}
	
	# TODO: Rename this param to parameters?
	rval = list(data = simulatedData, param = SIM_paramListToDF(combinedParam))
	
	if (combinedParameterList) {
	  rval$paramList = combinedParam
	}
	
	rval
}

# Internal function used by SIM_sampleDataSet
SIM_paramListToDF = function(paramList) {
	
	nPart = length(paramList[[1]])
	
	df = NULL
	
	for (pnum in 1:nPart) {
	  for (condName in names(paramList)) {
			
			pdata = paramList[[condName]][[pnum]]
			
			for (n in names(pdata)) {
				
				if (length(pdata[[n]]) == 0) {
					pdata[[n]] = NA
				}
				
				temp = data.frame(pnum = pnum, cond = condName, parName = n, cat = NA, value = pdata[[n]], stringsAsFactors = FALSE)
				if (n == "catMu") {
					temp$cat = 1:nrow(temp) #TODO MemFirst - 1
				}
				df = rbind(df, temp)
			}
		}
	}
	
	if (length(unique(df$cond)) > 1) {
		for (n in unique(df$parName)) {
			thisParam = df[ df$parName == n, ]
			
			conds = unique(thisParam$cond)
			firstCond = conds[1]
			otherConds = conds[2:length(conds)]
			
			allEqual = TRUE
			for (cond in otherConds) {
				eq = thisParam$value[ thisParam$cond == firstCond ] == thisParam$value[ thisParam$cond == cond ]
				allEqual = allEqual && all(eq)
			}
			
			if (!is.na(allEqual) && allEqual) {
				df = df[ !(df$parName == n & df$cond != firstCond), ]
			}
		}
	}
	
	df = df[ order(df$parName, df$cond, df$pnum), ]
	
	df = df[ !is.na(df$value), ]
	
	df
}


#' Sample Simulated Data Set for Testing
#' 
#' Sample test data with [`SIM_sampleDataSet`] using default parameter values from [`SIM_sampleParticipants`] and no condition effects.
#' 
#' @param modelVariant A model variant string.
#' @param nPart Number of participants to sample.
#' @param conds Names of conditions to sample.
#' @param nTrials Number of trials in each participant by condition cross.
#' @param linearRange Length 2 numeric vector giving ends of linear data range.
#' @param justData If `FALSE`, simulated parameter values will also be returned.
#' 
#' @return A simulated data set.
#' 
#' @family simulationFunctions
#' @export
SIM_sampleTestData = function(modelVariant, nPart=10, conds=LETTERS[1:4], nTrials=12, linearRange=NULL, justData=TRUE) {
  
  partParam = SIM_sampleParticipants(nPart, modelVariant=modelVariant)
  condEff = SIM_defineConditionEffects(length(conds), condNames = conds)
  
  dataType = ifelse(is.null(linearRange), "circular", "linear")
  
  sim = SIM_sampleDataSet(condEff, partParam, nTrials, modelVariant = modelVariant, dataType = dataType, studyRange = linearRange, responseRange = linearRange)
  
  if (justData) {
    return(sim$data)
  }
  
  sim
}



#####################################################
# Simluation success/parameter recovery functions


#' Parameter Recovery of Simulated Data Sets
#' 
#' Checks quality of parameter recovery for simulated data. Produces plots and numeric comparisons.
#' 
#' @param results From [`runParameterEstimation`].
#' @param trueParam True parameter values in a data frame. Formatted like the `paramDf` returned by [`SIM_sampleDataSet`].
#' @param pdfFile Name of pdf file to plot to.
#' @param roundDigits Rounding for numeric results.
#' @param cip Passed `cip` argument of [`SIM_testCredibleIntervals`].
#' 
#' @return Recovery statistics from [`SIM_calculateRecoveryStats`] in `recoveryStats`. Credible interval comparisons from [`SIM_testCredibleIntervals`] in `credInt`.
#' 
#' @family simulationFunctions
#' @export
SIM_checkParameterRecovery = function(results, trueParam, pdfFile=NULL, roundDigits=NULL, cip=0.95) {
  
  if (!resultIsType(results, "WP")) {
    stop("Parameter recovery checks only work on WP results objects.")
  }
  
  SIM_parameterRecoveryPlots(results, trueParam, pdfFile = pdfFile)
  
  credInt = SIM_testCredibleIntervals(results, trueParam, roundDigits=roundDigits, cip=cip)
  
  recoveryStats = SIM_calculateRecoveryStats(results, trueParam, roundDigits=roundDigits)
  
  list(credInt = credInt, recoveryStats = recoveryStats)
}


# trueParam like returned by SIM_paramListToDF
SIM_prepareTrueRecParam = function(results, trueParam) {
  
  trueParam$cond = as.character(trueParam$cond)
  
  trueParam$parName[ trueParam$parName == "nCat" ] = "catActive"
  trueParam$cond[ trueParam$parName == "catActive" ] = "ALL_CONDS"
  
  recPart = participantPosteriorSummary(results)
  recPart$value = recPart$mean
  
  trueKeep = unique(recPart$parName)
  if (results$config$modelVariant != "ZL") {
    trueKeep = c(trueKeep, "catMu")
  }
  
  trueParam = trueParam[ trueParam$parName %in% trueKeep, ]
  
  recPart$Reality = "Recovered"
  trueParam$Reality = "True"
  
  trueParam$pnum = as.character(trueParam$pnum)
  recPart$pnum = as.character(recPart$pnum)
  
  trueParam = trueParam[ order(trueParam$pnum), ]
  recPart = recPart[ order(recPart$pnum), ]
  
  
  commonColumns = c("Reality", "parName", "pnum", "cond", "value")
  
  recPart = recPart[ , commonColumns]
  trueParam = trueParam[ , commonColumns]
  
  list(true=trueParam, rec=recPart)
  
}

#' Compare True (Simulated) and Recovered (Estimated) Parameter Values
#' 
#' Calculates statistics related to parameter recovery.
#' 
#' @details The returned `difPercent` and `absDifPercent` columns are calculated per participant. 
#' The difference (or abs difference) between recovered and true values per participant is divided by the true value per participant.
#' The mean of those values is taken and multiplied by 100 to get percent.
#' 
#' @param results Results from [`runParameterEstimation`] (with burn-in iterations removed).
#' @param trueParam True parameter values formatted like the `paramDf` element in the list returned by [`SIM_sampleDataSet`].
#' @param roundDigits Round numeric columns of the returned data frame to this number of digits.
#' 
#' @return A `data.frame` with several columns. 
#' Includes the mean true and recovered values (`trueMean` and `trueRec`) for each condition, 
#' the mean difference between the true and recovered values (`difMean`),
#' the percent difference relative to the true values (`difPercent`),
#' several statistics for absolute differences (`absDifMean`, `absDifPercent`, `absDifMin`, `absDifMedian`, `absDifMax`),
#' correlation (`cor`) between true and recovered participant parameters,
#' and the `slope` of the best-fit line.
#' 
#' @family simulationFunctions
#' @export
SIM_calculateRecoveryStats = function(results, trueParam, roundDigits=NULL) {
  
  trp = SIM_prepareTrueRecParam(results, trueParam)
  prepTrue = trp$true
  prepRec = trp$rec
  
  rval = NULL
  
  commonParameters = intersect( unique(prepTrue$parName), unique(prepRec$parName) )
  
  for (parName in commonParameters) {
    
    conds = unique(prepTrue$cond[ prepTrue$parName == parName ])
    
    for (cond in conds) {
      
      rec = prepRec$value[ prepRec$parName == parName & prepRec$cond == cond ]
      true = prepTrue$value[ prepTrue$parName == parName & prepTrue$cond == cond ]
      
      difs = rec - true
      absDifs = abs(difs)
      
      temp = data.frame(parName = parName, cond = cond, stringsAsFactors = FALSE)
      
      temp$trueMean = mean(true)
      temp$recMean = mean(rec)
      
      temp$difMean = mean(difs)
      #temp$difMeanPercent = mean(difs) / mean(true) * 100
      
      temp$difPercent = mean((rec - true) / true) * 100
      
      temp$absDifMean = mean(absDifs)
      temp$absDifPercent = mean(abs(rec - true) / true) * 100
      
      temp$absDifMin = min(absDifs)
      temp$absDifMedian = stats::median(absDifs)
      temp$absDifMax = max(absDifs)
      
      
      #difPartPercent = 100 * (rec - true) / true
      #absDifPartPercent = 100 * abs(rec - true) / true

      
      # Correlation and slope
      temp$cor = stats::cor(rec, true)
      temp$slope = as.numeric(stats::coef(stats::lm(rec ~ true))[2])
      
      rval = rbind(rval, temp)
    }
  }
  
  if (!is.null(roundDigits)) {
    for (n in names(rval)) {
      if (all(is.numeric(rval[,n]))) {
        rval[,n] = round(rval[ , n ], roundDigits)
      }
    }
  }
  
  rval
}


#' Test if True Values are in Credible Intervals
#' 
#' Asks the question "Are true parameter values inside of the recovered credible intervals?"
#' Tests are done for standard parameters (all but `catMu` or `catActive`).
#' Tests are done for each participant parameter individually (like `catSD[pnum]`) and with the group mean (like `catSD.mu`).
#' 
#' @details
#' 
#' Tests are done in each condition, so although the condition effect parameters (like `catSD_cond[1]`) are not tested directly,
#' if a particular condition has credible intervals that don't contain the true value, that suggests that the condition effect parameter was not recovered well.
#' 
#' The returned list contains three elements. `mu` and `part` have the same format. 
#' The `parName`, `cond`, and `pnum` columns identify the parameter being tested.
#' `true` is the true parameter value, 
#' `ciLower` and `ciUpper` are the lower and upper bounds of the credible interval, 
#' and `ciContainsTrue` is `TRUE` if `true` is between `ciLower` and `ciUpper`.
#' 
#' `partAgg` uses `part` and takes the mean of `ciContainsTrue` for each condition by parameter cross.
#' Remember that the proportion of true values in the credible interval should equal the credible interval proportion (`cip`), not 100%.
#' 
#' 
#' @param results Results from [`runParameterEstimation`] (with burn-in iterations removed).
#' @param trueParam True parameter values formatted like the `paramDf` element in the list returned by [`SIM_sampleDataSet`].
#' @param cip Credible Interval Proportion.
#' @param roundDigits Round numeric columns of the returned data frame to this number of digits.
#' 
#' @return A list with a few elements. See details.
#' 
#' @family simulationFunctions
#' @export
SIM_testCredibleIntervals = function(results, trueParam, cip=0.95, roundDigits=NULL) {
  
  pc = unique(results$data[ , c("pnum", "cond")])
  
  paramNames = getParamNames(results$config$modelVariant, types=c("prob", "sd"))
  
  allCI = NULL
  
  for (parName in paramNames) {
    
    trans = getParameterTransformation(results, parName)
    
    for (cond in unique(results$data$cond)) {

      pnumsInCond = unique(results$data$pnum[results$data$cond == cond])
      
      true.cond = trueParam[ trueParam$parName == parName & trueParam$cond == cond, ]
      true.cond = true.cond[ true.cond$pnum %in% pnumsInCond, ]
      
      if (nrow(true.cond) == 0) {
        next
      }
      
      # pnum=NULL gives CI for .mu
      credInt = getParameterCredibleInterval(results, parName, pnum=NULL, cond=cond, cip=cip)

      trueMean = mean(true.cond$value)
      
      temp = data.frame(parName = parName, cond=cond, pnum=".mu", true=trueMean, ciLower=credInt[1], ciUpper=credInt[2])
      allCI = rbind(allCI, temp)
      
      for (pnum in pnumsInCond) {
        
        credInt = getParameterCredibleInterval(results, parName, pnum=pnum, cond=cond, cip=cip)
        
        true.part = true.cond$value[ true.cond$pnum == pnum ]
        
        temp = data.frame(parName = parName, cond=cond, pnum=pnum, true=true.part, ciLower=credInt[1], ciUpper=credInt[2])
        allCI = rbind(allCI, temp)
      }
      
    }
  }
  
  row.names(allCI) = NULL
  
  allCI$ciContainsTrue = allCI$true >= allCI$ciLower & allCI$true <= allCI$ciUpper
  
  if (!is.null(roundDigits)) {
    for (colname in c("true", "ciLower", "ciUpper")) {
      allCI[ , colname ] = round(allCI[, colname], roundDigits)
    }
  }
  
  justMu = allCI[ allCI$pnum == ".mu", ]
  justPart = allCI[ allCI$pnum != ".mu", ]
  
  partContains = stats::aggregate(ciContainsTrue ~ cond * parName, justPart, mean)
  
  rval = list(mu = justMu, partContains = partContains, part = justPart)
 
  rval
}




#' Plots of Simulation Parameter Recovery
#' 
#' Makes several plots that compare true parameter values to recovered parameter values for different model parameters.
#' + For parameters with condition effects, line chart of mean true and recovered values by condition.
#' + For parameters without condition effects, boxplot of participant parameter values. Recovered values are posterior mean.
#' + For parameters with or without condition effects, scatterplot of true (x) vs recovered (y) participant parameter values. Plotted line is intercept 0, slope 1. Red diamond is mean.
#' + For `catMu` parameter, density plot of posterior `catMu` with vertical lines at true `catMu` values.
#' 
#' @param results Results from [`runParameterEstimation`] (with burn-in iterations removed).
#' @param trueParam True parameter values formatted like the `paramDf` element in the list returned by [`SIM_sampleDataSet`].
#' @param pdfFile Name of a pdf file to plot to.
#' 
#' @return No return value.
#' 
#' @family simulationFunctions
#' @export
SIM_parameterRecoveryPlots = function(results, trueParam, pdfFile=NULL) {
  
  trp = SIM_prepareTrueRecParam(results, trueParam)
  prepTrue = trp$true
  prepRec = trp$rec
  
  if (!is.null(pdfFile)) {
    grDevices::pdf(pdfFile, width=10, height=5)
  }
  
  graphics::par(mfrow=c(1,2))
  
  commonParameters = intersect( unique(prepTrue$parName), unique(prepRec$parName) )
  paramOrd = getParamNames()
  commonParameters = paramOrd[ paramOrd %in% commonParameters ]
  
  for (parName in commonParameters) {
    
    thisTrue = prepTrue[ prepTrue$parName == parName, ]
    thisRec = prepRec[ prepRec$parName == parName, ]
    
    conds = unique(thisTrue$cond)
    
    thisRec = thisRec[ thisRec$cond == conds, ]
    
    # Central tendency
    tr = rbind(thisTrue, thisRec)
    if (length(conds) == 1) {
      graphics::boxplot(value ~ Reality, tr)
    } else {
      LineChart::lineChart(value ~ cond * Reality, tr, errBarType = "none")
    }
    graphics::title(parName)
    
    # Scatterplot (only for cornerstone cond)
    csName = results$config$cornerstoneConditionName
    if (parName == "catActive") {
      csName = unique(thisTrue$cond)
    }
    
    csTrue = thisTrue[ thisTrue$cond == csName, ]
    csRec = thisRec[ thisRec$cond == csName, ]
    
    corr = stats::cor(csTrue$value, csRec$value)
    
    plot(csTrue$value, csRec$value, xlab="True", ylab="Recovered", 
         main=paste0("Cor=", round(corr, 2)))
    graphics::abline(0, 1)
    graphics::points(mean(csTrue$value), mean(csRec$value), col="red", pch=18, cex=2)
    
  }
  
  # catMu
  if (results$config$modelVariant != "ZL") {
    graphics::par(mfrow=c(1,1))
    for (pnum in results$pnums) {
      
      trueMu = prepTrue$value[ prepTrue$parName == "catMu" & prepTrue$pnum == pnum ]
      
      plotCatMu(results, pnums=pnum)
      graphics::abline(v=trueMu, col="red", lwd=2)
      
      graphics::title(paste0("catMu pnum=", pnum))
    }
  }
  
  
  if (!is.null(pdfFile)) {
    grDevices::dev.off()
  }
  
}


# This function only works under narrow conditions, like when catMu is shared.
SIM_catMuRecovery = function(results, trueParam) {
  
  post = convertPosteriorsToMatrices(results)
  
  catActive01 = apply(post$catActive, c(1,2), mean)
  
  catActive01[ catActive01 < 0.5 ] = 0
  catActive01[ catActive01 >= 0.5 ] = 1
  
  catMuRec = apply(post$catMu, 2, CatContModel::circMean)
  catMuRec = round(catMuRec, 0)
  
  trueRecCatMu = NULL
  
  for (pnum in results$pnums) {
    
    thisCatMuRec = catMuRec[catActive01[pnum,] == 1]
    thisCatMuRec = sort(thisCatMuRec)
    
    trueCatMu = trueParam$value[ trueParam$parName == "catMu" & trueParam$pnum == pnum ]
    trueCatMu = sort(trueCatMu)
    
    maxCats = max(length(thisCatMuRec), length(trueCatMu))
    temp = data.frame(pnum=pnum, true=rep(NA, maxCats), rec=rep(NA, maxCats))
    temp$true[1:length(trueCatMu)] = trueCatMu
    temp$rec[1:length(thisCatMuRec)] = thisCatMuRec
    trueRecCatMu = rbind(trueRecCatMu, temp)
  }
  
  trueRecCatMu$dif = trueRecCatMu$true - trueRecCatMu$rec
  
  trueRecCatMu
}
